1. 假设String类有如下私有成员：
class String
{
	private:
		char * str;
		int len;
// .....
};
a. 下述默认构造函数有什么问题?
String::String(){}
语法正确，但没有将str指针初始化。应将指针设置成NULL或使用new[]来初始化它。
b. 下述构造函数有什么问题?
String::String(const char * s)
{
	str = s;
	len = strlen(s);
}
该构造函数没有创建新的字符串，而只是复制了原因字符串的地址。应当使用new[]和strcpy[]。
c. 下述构造函数有什么问题?
String::String(const char * s)
{
	strcpy(str, s);
	len = strlen(s);
}
该构造函数复制了字符串，但没有给它分配存储空间，应使用new char[len + 1]来分配适当数量的内存。
2. 如果你定义了一个类，其指针成员是使用new初始化的，请指出可能出现的3个问题以及如何纠正这些问题。
1）当这种类型的对象过期时，对象的成员指针指向的数据仍将保留在内存中，这将占用空间，同时不可访问，因为指针已经丢失。
解决办法：让类析构函数删除构造函数中new分配的内存
2）若析构函数释放内存，如果程序将这样的对象初始化为另一个对象，则析构函数将试图释放这块内存两次。原因是将一个对象初始化为另一个对象
的默认初始化，将复制指针值，但不复制指向的数据。这将使两个指针指向相同的数据。
解决办法：定义一个复制构造函数，使初始化复制指向的数据。
3）将一个对象赋给另一个对象也将导致两个指针指向相同的数据。
解决办法：重载赋值运算符，使之复制数据，而不是指针。
3. 如果没有显式提供类方法，编译器将自动生成哪些类方法？请描述这些隐式生成的函数的行为。
默认构造函数、复制构造函数、赋值运算符、默认析构函数、地址运算符
默认构造函数不完成任何工作，但使得能够声明数组和未初始化的对象。
默认复制构造函数和默认赋值运算符使用成员赋值。
默认析构函数也不完成任何工作。
隐式地址运算符返回调用对象的地址（即this指针的值）。 

