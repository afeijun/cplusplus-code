1.略
2.你知道了如何建立相互类友元的方法。能够创建一种更为严格的友情关系，即类B只有部分成员是类A的友元，而类A只有部分成员是类B的友元吗？
请解释原因。
答：不能。为使类A拥有一个本身为类B的成员函数的友元，B的声明必须位于A的声明之前。
一个前向声明是不够的，因为这种声明可以告诉A：B是一个类;但它不能指出类成员的名称。
同样，如果B拥有一个本身是A的成员函数的友元，则A的这个声明必须位于B的声明之前。这两个要求是互斥的。
3.略
4.throw和return之间的区别何在？
答：假设函数f1()调用函数f2()。f2()中的返回语句导致程序执行在函数f1()中调用函数f2()后面的一条语句。
throw语句导致程序沿函数调用的当前序列回溯，直到找到直接或间接包含对f2()的调用的try语句块为止。
它可能在f1()中、调用f1()的函数中或其他函数中。找到这样的try语句块后，将执行下一个匹配的catch语句块，
而不是函数调用后的语句。
5.假设有一个从异常基类派生来的异常类层次结构，则应按什么样的顺序放置catch块？
答：应按从子孙到祖先的顺序排列catch语句块。
6.略
7.static_cast运算符与dynamic_cast运算符有什么不同?
答：dynamic_cast运算符只允许沿类层次结构向上转换，而static_cast运算符允许向上转换和向下转换。
    static_cast运算符还允许枚举类型和整型之间以及数值类型之间的转换。
